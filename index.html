<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <!-- Поддержка масштабирования на мобильных устройствах -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Pilots Jump</title>

  <!-- =================== CSS СТИЛИ =================== -->
  <style>
    /* Сброс отступов */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: 'Gloria Hallelujah', cursive;
      background: #f5f0e8;
    }

    /* Контейнер всей игры */
    #gameContainer {
      position: relative;
      width: 100vw;
      height: 100vh;
      background: url(https://i.imgur.com/Y0BMP.png) top left;
      overflow: hidden;
    }

    /* Canvas для рисования */
    #canvas {
      display: block;
      width: 100%;
      height: 100%;
      background: transparent;
    }

    /* Скрываем <img> со спрайтом */
    #sprite {
      display: none;
    }

    /* ----- ГЛАВНОЕ МЕНЮ «PLAY» ----- */
    #mainMenu {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255,255,255,0.9);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }
    #mainMenu h1 {
      font-size: 48px;
      color: #5a5816;
      transform: rotate(-10deg);
      margin-bottom: 10px;
      text-align: center;
    }
    #mainMenu h3 {
      font-size: 20px;
      color: #5e96be;
      margin-bottom: 30px;
      text-align: center;
    }
    #btnPlay {
      width: 120px;
      height: 40px;
      background: url(https://i.imgur.com/2WEhF.png) 0 0 no-repeat;
      text-align: center;
      line-height: 40px;
      font-size: 16px;
      color: #000;
      cursor: pointer;
      margin-top: 20px;
    }

    /* ----- МЕНЮ «GAME OVER» ----- */
    #gameOverMenu {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255,255,255,0.9);
      display: none;               /* скрыто по умолчанию */
      flex-direction: column;
      justify-content: flex-start; /* немного вниз, чтобы не закрывать заголовок */
      align-items: center;
      padding-top: 40px;
      z-index: 10;
    }
    #gameOverMenu h1 {
      font-size: 48px;
      color: #a33;
      transform: rotate(-5deg);
      margin-bottom: 10px;
      text-align: center;
    }
    #gameOverMenu h3 {
      font-size: 20px;
      color: #333;
      margin-bottom: 10px;
      text-align: center;
    }
    #btnRestart {
      width: 120px;
      height: 40px;
      background: url(https://i.imgur.com/2WEhF.png) 0 -60px no-repeat;
      text-align: center;
      line-height: 40px;
      font-size: 16px;
      color: #000;
      cursor: pointer;
      margin-bottom: 20px;
    }

    /* ----- СЧЁТЧИК ОЧКОВ ----- */
    #scoreBoard {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(182,200,220,0.7);
      padding: 5px 10px;
      border-radius: 5px;
      display: none;  /* показываем, когда игра началась */
      z-index: 5;
    }
    #scoreBoard p {
      font-size: 18px;
      color: #000;
    }

    /* ----- ИНСТРУКЦИЯ СНИЗУ ----- */
    #infoText {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: green;
      font-size: 14px;
      z-index: 5;
      text-align: center;
    }

    /* ----- НЕВИДИМЫЕ ЗОНЫ УПРАВЛЕНИЯ (касаемся левой/правой половины) ----- */
    #leftZone, #rightZone {
      position: absolute;
      top: 0;
      width: 50%;
      height: 100%;
      z-index: 2;
    }
    #leftZone { left: 0; }
    #rightZone { right: 0; }

    /* ----- ТАБЛИЦА ЛИДЕРОВ ----- */
    #leaderboard {
      width: 90%;
      max-width: 350px;
      margin-top: 20px;
      border: 2px solid #5a5816;
      border-radius: 8px;
      background: #fff;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
      display: none;  /* показываем только после Game Over */
    }
    #leaderboard h4 {
      background: #5a5816;
      color: #fff;
      padding: 6px 0;
      text-align: center;
      font-size: 18px;
      margin: 0;
      border-top-left-radius: 6px;
      border-top-right-radius: 6px;
    }
    #leaderboard table {
      width: 100%;
      border-collapse: collapse;
    }
    #leaderboard th, #leaderboard td {
      padding: 6px 4px;
      text-align: left;
      font-size: 14px;
      border-bottom: 1px solid #ddd;
    }
    #leaderboard th {
      background: #e8e8e8;
      font-weight: bold;
    }
    #leaderboard tr:last-child td {
      border-bottom: none;
    }
  </style>
</head>
<body>
  <!-- ===== КОНТЕЙНЕР ИГРЫ ===== -->
  <div id="gameContainer">
    <!-- Canvas для рисования -->
    <canvas id="canvas"></canvas>

    <!-- Скрытый <img> со спрайтом -->
    <img id="sprite" src="https://i.imgur.com/2WEhF.png" alt="spritesheet" />

    <!-- ===== ГЛАВНОЕ МЕНЮ «PLAY» ===== -->
    <div id="mainMenu">
      <h1>Pilots Jump</h1>
      <h3>Hey Pilot, ...by Second Pilots 3D</h3>
      <div id="btnPlay">Play</div>
    </div>

    <!-- ===== МЕНЮ «GAME OVER» ===== -->
    <div id="gameOverMenu">
      <h1>Game Over!</h1>
      <h3 id="go_score">You scored 0 points</h3>
      <div id="btnRestart">Restart</div>

      <!-- Блок с таблицей лидеров (Leaderboard) -->
      <div id="leaderboard">
        <h4>Leaderboard</h4>
        <table>
          <thead>
            <tr>
              <th>#</th>
              <th>Player</th>
              <th>Best Score</th>
            </tr>
          </thead>
          <tbody id="lb_body">
            <!-- сюда динамически добавятся строки топ-10 -->
          </tbody>
        </table>
      </div>
    </div>

    <!-- ===== СЧЁТЧИК ОЧКОВ ===== -->
    <div id="scoreBoard">
      <p id="score">0</p>
    </div>

    <!-- ===== ИНСТРУКЦИЯ ===== -->
    <div id="infoText">use ← → to move and space to (re)start…</div>

    <!-- ===== НЕВИДИМЫЕ ЗОНЫ КАСАНИЯ ===== -->
    <div id="leftZone"></div>
    <div id="rightZone"></div>
  </div>

  <!-- ================== JS-КОД ================== -->
  <script>
    // 1) Работа с Canvas и контейнером
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    let width, height;

    function setCanvasSizeAndContainer() {
      const container = document.getElementById("gameContainer");
      if (typeof Telegram !== "undefined" && Telegram.WebApp) {
        const navbarHeight =
          parseInt(
            getComputedStyle(document.documentElement)
              .getPropertyValue("--tg-nav-bar-height")
          ) || 0;
        container.style.width = "100vw";
        container.style.height = `calc(100vh - ${navbarHeight}px)`;
        container.style.marginTop = `${navbarHeight}px`;
        width = container.clientWidth;
        height = container.clientHeight;
      } else {
        container.style.width = "100vw";
        container.style.height = "100vh";
        container.style.marginTop = "0";
        width = container.clientWidth;
        height = container.clientHeight;
      }
      canvas.width = width;
      canvas.height = height;
    }

    setCanvasSizeAndContainer();
    window.addEventListener("resize", setCanvasSizeAndContainer);

    if (typeof Telegram !== "undefined" && Telegram.WebApp) {
      Telegram.WebApp.ready();
    }

    // 2) Игровые переменные и инициализация
    let platforms = [];
    const image = document.getElementById("sprite");
    let player, base, Spring, platform_broken_substitute;

    const platformCount = 10;
    let position = 0,
        gravity = 0.2,
        animloop,
        flag = 0,
        broken = 0,
        dir = "left",
        score = 0,
        jumpCount = 0;

    // ==================== КЛАССЫ ====================
    class Base {
      constructor() {
        this.height = 5;
        this.width = width;
        this.cx = 0;      this.cy = 614;
        this.cwidth = 100; this.cheight = 5;
        this.x = 0;       this.y = height - this.height;
      }
      draw() {
        try {
          ctx.drawImage(
            image,
            this.cx, this.cy, this.cwidth, this.cheight,
            this.x, this.y, this.width, this.height
          );
        } catch (e) {}
      }
    }

    class Player {
      constructor() {
        this.vy = 11;       // стартовая вертикальная скорость
        this.vx = 0;
        this.isMovingLeft = false;
        this.isMovingRight = false;
        this.isDead = false;
        this.width = 55;
        this.height = 40;
        this.cx = 0;      this.cy = 0;
        this.cwidth = 110; this.cheight = 80;
        this.dir = "left";
        this.x = width / 2 - this.width / 2;
        this.y = height;
      }
      draw() {
        try {
          if (this.dir === "right") this.cy = 121;
          else if (this.dir === "left") this.cy = 201;
          else if (this.dir === "right_land") this.cy = 289;
          else if (this.dir === "left_land") this.cy = 371;

          ctx.drawImage(
            image,
            this.cx, this.cy, this.cwidth, this.cheight,
            this.x, this.y, this.width, this.height
          );
        } catch (e) {}
      }
      jump() {
        // ВОССТАНОВЛЕНО к оригиналу: -8
        this.vy = -8;
      }
      jumpHigh() {
        // ВОССТАНОВЛЕНО к оригиналу: -16
        this.vy = -16;
      }
    }

    class Platform {
      constructor() {
        // Шире: 100px (вместо 70px)
        this.width = 100;
        this.height = 17;
        this.x = Math.random() * (width - this.width);
        this.y = position;
        // «Оригинальный» шаг между платформами:
        position += height / platformCount;
        this.flag = 0;
        this.state = 0;
        this.cx = 0;      this.cy = 0;
        this.cwidth = 105; this.cheight = 31;

        if (score >= 5000) this.types = [2, 3, 3, 3, 4, 4, 4, 4];
        else if (score >= 2000 && score < 5000)
          this.types = [2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4];
        else if (score >= 1000 && score < 2000) this.types = [2, 2, 2, 3, 3, 3, 3, 3];
        else if (score >= 500 && score < 1000)
          this.types = [1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3];
        else if (score >= 100 && score < 500) this.types = [1, 1, 1, 1, 2, 2];
        else this.types = [1];

        this.type = this.types[Math.floor(Math.random() * this.types.length)];

        if (this.type === 3 && broken < 1) {
          broken++;
        } else if (this.type === 3 && broken >= 1) {
          this.type = 1;
          broken = 0;
        }
        this.vx = 1;
      }
      draw() {
        try {
          if (this.type === 1) this.cy = 0;
          else if (this.type === 2) this.cy = 61;
          else if (this.type === 3 && this.flag === 0) this.cy = 31;
          else if (this.type === 3 && this.flag === 1) this.cy = 1000;
          else if (this.type === 4 && this.state === 0) this.cy = 90;
          else if (this.type === 4 && this.state === 1) this.cy = 1000;

          ctx.drawImage(
            image,
            this.cx, this.cy, this.cwidth, this.cheight,
            this.x, this.y, this.width, this.height
          );
        } catch (e) {}
      }
    }

    class PlatformBrokenSub {
      constructor() {
        this.height = 30;
        this.width = 100;
        this.x = 0;
        this.y = 0;
        this.cx = 0;      this.cy = 554;
        this.cwidth = 105; this.cheight = 60;
        this.appearance = false;
      }
      draw() {
        try {
          if (this.appearance) {
            ctx.drawImage(
              image,
              this.cx, this.cy, this.cwidth, this.cheight,
              this.x, this.y, this.width, this.height
            );
          }
        } catch (e) {}
      }
    }

    class SpringClass {
      constructor() {
        this.x = 0;
        this.y = 0;
        this.width = 26;
        this.height = 30;
        this.cx = 0;      this.cy = 0;
        this.cwidth = 45; this.cheight = 53;
        this.state = 0;
      }
      draw() {
        try {
          if (this.state === 0) this.cy = 445;
          else if (this.state === 1) this.cy = 501;
          ctx.drawImage(
            image,
            this.cx, this.cy, this.cwidth, this.cheight,
            this.x, this.y, this.width, this.height
          );
        } catch (e) {}
      }
    }

    // ==================== ФУНКЦИИ ====================
    function paintCanvas() {
      ctx.clearRect(0, 0, width, height);
    }

    function playerCalc() {
      if (dir === "left") {
        player.dir = "left";
        if (player.vy < -7 && player.vy > -15) player.dir = "left_land";
      } else if (dir === "right") {
        player.dir = "right";
        if (player.vy < -7 && player.vy > -15) player.dir = "right_land";
      }

      // Горизонтальная физика (уменьшенная чувствительность)
      if (player.isMovingLeft) { player.x += player.vx; player.vx -= 0.08; }
      else { player.x += player.vx; if (player.vx < 0) player.vx += 0.05; }
      if (player.isMovingRight) { player.x += player.vx; player.vx += 0.08; }
      else { player.x += player.vx; if (player.vx > 0) player.vx -= 0.05; }
      if (player.vx > 8) player.vx = 8;
      else if (player.vx < -8) player.vx = -8;

      // Прыжок от базы
      if ((player.y + player.height) > base.y && base.y < height) {
        player.jump();
      }

      // Game Over
      if (
        base.y > height &&
        player.y + player.height > height &&
        player.isDead !== "lol"
      ) {
        player.isDead = true;
      }

      // Сквозь стены
      if (player.x > width) player.x = -player.width;
      else if (player.x < -player.width) player.x = width;

      // Вертикальная физика + скролл
      if (player.y >= height / 2 - player.height / 2) {
        player.y += player.vy;
        player.vy += gravity;
      } else {
        platforms.forEach((p, i) => {
          if (player.vy < 0) p.y -= player.vy;
          if (p.y > height) {
            platforms[i] = new Platform();
            platforms[i].y = p.y - height;
          }
        });
        base.y -= player.vy;
        player.vy += gravity;
        if (player.vy >= 0) {
          player.y += player.vy;
          player.vy += gravity;
        }
        score++;
      }

      collides();
      if (player.isDead) {
        gameOver();
      }
    }

    function springCalc() {
      let s = Spring;
      let p = platforms[0];
      if (p.type === 1 || p.type === 2) {
        s.x = p.x + p.width / 2 - s.width / 2;
        s.y = p.y - p.height - 10;
        if (s.y > height / 1.1) s.state = 0;
        s.draw();
      } else {
        s.x = -s.width;
        s.y = -s.height;
      }
    }

    function platformCalc() {
      let subs = platform_broken_substitute;
      platforms.forEach((p, i) => {
        if (p.type === 2) {
          if (p.x < 0 || p.x + p.width > width) p.vx *= -1;
          p.x += p.vx;
        }
        if (p.flag === 1 && !subs.appearance && jumpCount === 0) {
          subs.x = p.x;
          subs.y = p.y;
          subs.appearance = true;
          jumpCount++;
        }
        p.draw();
      });
      if (subs.appearance) {
        subs.draw();
        subs.y += 8;
      }
      if (subs.y > height) subs.appearance = false;      
    }

    function collides() {
      platforms.forEach((p, i) => {
        if (
          player.vy > 0 &&
          p.state === 0 &&
          player.x + 15 < p.x + p.width &&
          player.x + player.width - 15 > p.x &&
          player.y + player.height > p.y &&
          player.y + player.height < p.y + p.height
        ) {
          if (p.type === 3 && p.flag === 0) {
            p.flag = 1;
            jumpCount = 0;
            return;
          } else if (p.type === 4 && p.state === 0) {
            player.jump();
            p.state = 1;
          } else if (p.flag === 1) {
            return;
          } else {
            player.jump();
          }
        }
      });

      let s = Spring;
      if (
        player.vy > 0 &&
        s.state === 0 &&
        player.x + 15 < s.x + s.width &&
        player.x + player.width - 15 > s.x &&
        player.y + player.height > s.y &&
        player.y + player.height < s.y + s.height
      ) {
        s.state = 1;
        player.jumpHigh();
      }
    }

    function updateScore() {
      document.getElementById("score").innerText = score;
    }

    // Функция отправки результата на сервер
    async function submitScoreToServer(userId, scoreValue) {
      try {
        const response = await fetch("https://ваш_сервер/api/submit_score", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            user_id: userId,
            score: scoreValue
          })
        });
        const data = await response.json();
        return data; // { success: true/false, personal_best: <число> }
      } catch (err) {
        console.error("Error submitting score:", err);
        return null;
      }
    }

    // Функция для получения топ-10
    async function fetchTop10() {
      try {
        const response = await fetch("https://ваш_сервер/api/top10");
        const data = await response.json();
        return data.top10; // массив объектов { username, best_score }
      } catch (err) {
        console.error("Error fetching top10:", err);
        return [];
      }
    }

    // Покажем таблицу лидеров после Game Over
    async function showLeaderboard(userId, finalScore) {
      const lbDiv = document.getElementById("leaderboard");
      const lbBody = document.getElementById("lb_body");

      // 1) Отправляем свой счёт на сервер
      const submitResult = await submitScoreToServer(userId, finalScore);
      if (!submitResult) {
        console.warn("Не удалось отправить счёт, получаем только топ-10.");
      }

      // 2) Получаем топ-10
      const topList = await fetchTop10();

      // 3) Очищаем предыдущие строки
      lbBody.innerHTML = "";

      // 4) Пишем топ-10
      for (let i = 0; i < topList.length; i++) {
        const row = document.createElement("tr");
        const cellRank = document.createElement("td");
        const cellName = document.createElement("td");
        const cellScore = document.createElement("td");

        cellRank.innerText = i + 1;
        cellName.innerText = topList[i].username;
        cellScore.innerText = topList[i].best_score;

        row.appendChild(cellRank);
        row.appendChild(cellName);
        row.appendChild(cellScore);
        lbBody.appendChild(row);
      }

      // 5) Показываем
      lbDiv.style.display = "block";
    }

    // Game Over с вызовом Leaderboard
    async function gameOver() {
      platforms.forEach((p) => {
        p.y -= 12;
      });
      if (player.y > height / 2 && flag === 0) {
        player.y -= 8;
        player.vy = 0;
      } else if (player.y < height / 2) {
        flag = 1;
      } else if (player.y + player.height > height) {
        showGameOverMenu();
        hideScore();

        // Берём user_id из Telegram WebApp; если нет — 0
        let userId = null;
        if (typeof Telegram !== "undefined" && Telegram.WebApp) {
          const initData = Telegram.WebApp.initDataUnsafe || {};
          userId = initData.user ? initData.user.id : null;
        }
        userId = userId || 0;
        await showLeaderboard(userId, score);

        player.isDead = "lol";
      }
    }

    function update() {
      paintCanvas();
      platformCalc();
      springCalc();
      playerCalc();
      player.draw();
      base.draw();
      updateScore();
    }

    // ===== ИНИЦИАЛИЗАЦИЯ ИГРЫ =====
    function init() {
      jumpCount = 0;
      // «Опустить» платформы на треть экрана
      position = height / 3;
      score = 0;
      flag = 0;
      broken = 0;

      base = new Base();
      player = new Player();
      Spring = new SpringClass();
      platform_broken_substitute = new PlatformBrokenSub();
      platforms = [];
      for (let i = 0; i < platformCount; i++) {
        platforms.push(new Platform());
      }

      // Скрываем GameOverMenu и Leaderboard
      hideGameOverMenu();
      document.getElementById("leaderboard").style.display = "none";

      paintCanvas();
      animloop = function () {
        update();
        requestAnimationFrame(animloop);
      };
      animloop();

      hideMainMenu();
      showScore();
    }

    function reset() {
      hideGameOverMenu();
      document.getElementById("leaderboard").style.display = "none";
      showScore();
      player.isDead = false;
      flag = 0;
      broken = 0;
      // Снова «опустить» платформы
      position = height / 3;
      score = 0;
      jumpCount = 0;

      base = new Base();
      player = new Player();
      Spring = new SpringClass();
      platform_broken_substitute = new PlatformBrokenSub();
      platforms = [];
      for (let i = 0; i < platformCount; i++) {
        platforms.push(new Platform());
      }
    }

    function hideMainMenu() {
      document.getElementById("mainMenu").style.display = "none";
    }
    function showGameOverMenu() {
      document.getElementById("gameOverMenu").style.display = "flex";
    }
    function hideGameOverMenu() {
      document.getElementById("gameOverMenu").style.display = "none";
    }
    function showScore() {
      document.getElementById("scoreBoard").style.display = "flex";
    }
    function hideScore() {
      document.getElementById("scoreBoard").style.display = "none";
    }

    // ===== ОБРАБОТЧИКИ ==========
    document.getElementById("btnPlay").addEventListener("click", init);
    document.getElementById("btnRestart").addEventListener("click", reset);

    // ===== НЕВИДИМЫЕ ЗОНЫ УПРАВЛЕНИЯ ======
    const leftZone = document.getElementById("leftZone");
    const rightZone = document.getElementById("rightZone");

    leftZone.addEventListener("mousedown", () => {
      dir = "left";
      player.isMovingLeft = true;
    });
    leftZone.addEventListener("mouseup", () => {
      player.isMovingLeft = false;
    });
    leftZone.addEventListener("mouseleave", () => {
      player.isMovingLeft = false;
    });
    leftZone.addEventListener("touchstart", (e) => {
      e.preventDefault();
      dir = "left";
      player.isMovingLeft = true;
    });
    leftZone.addEventListener("touchend", (e) => {
      e.preventDefault();
      player.isMovingLeft = false;
    });

    rightZone.addEventListener("mousedown", () => {
      dir = "right";
      player.isMovingRight = true;
    });
    rightZone.addEventListener("mouseup", () => {
      player.isMovingRight = false;
    });
    rightZone.addEventListener("mouseleave", () => {
      player.isMovingRight = false;
    });
    rightZone.addEventListener("touchstart", (e) => {
      e.preventDefault();
      dir = "right";
      player.isMovingRight = true;
    });
    rightZone.addEventListener("touchend", (e) => {
      e.preventDefault();
      player.isMovingRight = false;
    });
  </script>
  <!-- ================== КОНЕЦ JS-КОДА ================== -->
</body>
</html>
