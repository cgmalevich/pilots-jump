<!DOCTYPE HTML>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Pilots Jump — Исправленная версия</title>

  <!-- Telegram Web App SDK (не вызовет ошибок, если запущено локально) -->
  <script src="https://telegram.org/js/telegram-web-app.js"></script>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>

  <style>
    /* ======= Сбросы ======= */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #ffffff;
    }
    button {
      user-select: none;
    }

    /* ======= Контейнер игры ======= */
    .container {
      position: relative;
      margin: 0 auto;
      background: #fdf7ec; /* светлый фон */
      overflow: hidden;

      /* По умолчанию локально фиксированные размеры 422×552.
         Если запущено внутри Telegram WebApp, JS изменит эти стили. */
      width: 422px;
      height: 552px;
    }

    /* ======= Canvas ======= */
    canvas {
      display: block;
      width: 422px;
      height: 552px;
      background: url(https://i.imgur.com/Y0BMP.png) top left no-repeat;
    }

    /* ======= Табло со счётом ======= */
    #scoreBoard {
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: 50px;
      background: rgba(182, 200, 220, 0.7);
      display: none; /* по умолчанию скрыто */
      align-items: center;
      padding-left: 10px;
      font-family: 'Gloria Hallelujah', cursive;
      font-size: 20px;
      z-index: 2;
    }
    #scoreBoard p {
      margin: 0;
      line-height: 50px;
    }

    /* ======= Главное меню ======= */
    #mainMenu {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(255,255,255,0.9);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      font-family: 'Gloria Hallelujah', cursive;
      z-index: 3;
    }
    #mainMenu h1 {
      font-size: 3rem;
      color: #5a5816;
      transform: rotate(-10deg);
      margin-bottom: 0.5rem;
    }
    #mainMenu h3 {
      font-size: 1.1rem;
      color: #5e96be;
      margin-bottom: 0.2rem;
    }
    #mainMenu h3 a {
      color: #5a5816;
      text-decoration: none;
    }
    #mainMenu .info {
      font-size: 1.1rem;
      color: green;
      margin: 1rem 0;
    }
    #mainMenu .info .key {
      display: inline-block;
      width: 16px; height: 16px;
      background: url(https://i.imgur.com/2WEhF.png) no-repeat;
      text-indent: -9999px;
      vertical-align: middle;
    }
    #mainMenu .info .key.left  { background-position: -92px -621px; }
    #mainMenu .info .key.right { background-position: -92px -641px; }

    #mainMenu .button {
      background: #8dc63f url(https://i.imgur.com/2WEhF.png) no-repeat center center;
      background-size: cover;
      color: #000;
      font-size: 1rem;
      width: 120px; height: 40px;
      border: none;
      border-radius: 5px;
      line-height: 40px;
      cursor: pointer;
    }

    /* ======= Меню «Game Over» ======= */
    #gameOverMenu {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(255,255,255,0.9);
      display: none; /* изначально скрыто */
      flex-direction: column;
      justify-content: center;
      align-items: center;
      font-family: 'Gloria Hallelujah', cursive;
      z-index: 3;
    }
    #gameOverMenu h1 {
      font-size: 3rem;
      color: #5a5816;
      transform: rotate(-10deg);
      margin-bottom: 0.5rem;
    }
    #gameOverMenu h3 {
      font-size: 1.1rem;
      color: #5e96be;
      margin-bottom: 0.2rem;
    }
    #gameOverMenu .button {
      background: #8dc63f url(https://i.imgur.com/2WEhF.png) no-repeat center center;
      background-size: cover;
      color: #000;
      font-size: 1rem;
      width: 120px; height: 40px;
      border: none;
      border-radius: 5px;
      line-height: 40px;
      cursor: pointer;
      margin-top: 1rem;
    }

    /* ======= On-screen кнопки управления (←/→) ======= */
    #touchControls {
      position: absolute;
      width: 100%;
      bottom: 10px; left: 0;
      text-align: center;
      z-index: 3;
    }
    #touchControls button {
      width: 50px; height: 50px;
      margin: 0 15px;
      font-size: 1.5rem;
      line-height: 50px;
      background: rgba(200,200,200,0.6);
      border: none;
      border-radius: 5px;
      cursor: pointer;
      outline: none;
    }
    #touchControls button:active {
      background: rgba(150,150,150,0.8);
    }

    /* ======= Скрытый спрайт ======= */
    img#sprite {
      display: none;
    }
  </style>
</head>
<body>

  <div class="container" id="gameContainer">
    <!-- Табло со счётом -->
    <div id="scoreBoard"><p id="score">0</p></div>
    <!-- Canvas -->
    <canvas id="canvas">Ваш браузер не поддерживает Canvas</canvas>

    <!-- Главное меню -->
    <div id="mainMenu">
      <h1>Pilots Jump</h1>
      <h3>Hey Pilot,</h3>
      <h3>...by <a href="https://t.me/secondpilots_cg" target="_blank">Second Pilots 3D</a></h3>
      <div class="info">
        use <span class="key left">←</span> <span class="key right">→</span> to move and space to (re)start…
      </div>
      <!-- Привязываем запуск через onclick -->
      <button class="button" onclick="init()">Play</button>
    </div>

    <!-- Меню «Game Over» -->
    <div id="gameOverMenu">
      <h1>game over!</h1>
      <h3 id="go_score">You scored 0 points!</h3>
      <button class="button" onclick="reset()">Restart</button>
    </div>

    <!-- Подгружаемый спрайт (скрыт) -->
    <img id="sprite" src="https://i.imgur.com/2WEhF.png" />

    <!-- On-screen кнопки управления -->
    <div id="touchControls">
      <button id="leftBtn">←</button>
      <button id="rightBtn">→</button>
    </div>
  </div>

  <script>
    // ======== Telegram WebApp: определяем, запущено ли внутри Telegram ========
    const isTelegram = (typeof Telegram !== 'undefined' && Boolean(Telegram.WebApp));
    if (isTelegram) {
      // Уведомляем Telegram, что WebApp готов
      Telegram.WebApp.ready();

      // Функция подгоняет размеры .container и canvas под весь экран WebApp
      function adjustForWebApp() {
        // Telegram задаёт CSS-переменную --tg-nav-bar-height
        const navbarHeight = parseInt(
          getComputedStyle(document.documentElement).getPropertyValue('--tg-nav-bar-height')
        ) || 0;

        const container = document.getElementById('gameContainer');
        container.style.width  = '100vw';
        container.style.height = `calc(100vh - ${navbarHeight}px)`;

        const canvasEl = document.getElementById('canvas');
        canvasEl.style.width  = '100%';
        canvasEl.style.height = '100%';
      }

      adjustForWebApp();
      window.addEventListener('resize', adjustForWebApp);
    }

    // ======== Canvas: получаем 2D-контекст и задаём размеры ========
    const canvas = document.getElementById('canvas');
    const ctx    = canvas.getContext('2d');
    let   width, height;

    function setCanvasSize() {
      if (isTelegram) {
        // Внутри Telegram WebApp canvas растягивается на 100% от .container
        width  = canvas.offsetWidth;
        height = canvas.offsetHeight;
        canvas.width  = width;
        canvas.height = height;
      } else {
        // Локально фиксированные размеры
        width  = 422;
        height = 552;
        canvas.width  = width;
        canvas.height = height;
      }
    }
    setCanvasSize();
    window.addEventListener('resize', setCanvasSize);

    // ======== Переменные игры ========
    let platforms            = [];
    let image                = document.getElementById("sprite");
    let player, 
        platformCount        = 10,
        position             = 0,
        gravity              = 0.2,
        animloop,
        flag                 = 0,
        broken               = 0,
        dir                  = 'left',
        score                = 0,
        firstRun             = true,
        jumpCount            = 0;

    // ======== Определяем классы ========
    class Base {
      constructor() {
        this.height  = 5;
        this.width   = width;
        this.cx      = 0;
        this.cy      = 614;
        this.cwidth  = 100;
        this.cheight = 5;
        this.x       = 0;
        this.y       = height - this.height;
      }
      draw() {
        try {
          ctx.drawImage(
            image,
            this.cx, this.cy, this.cwidth, this.cheight,
            this.x,   this.y,   this.width,  this.height
          );
        } catch (e) { /* игнорируем, пока спрайт не загрузился */ }
      }
    }
    let base = new Base();

    class Player {
      constructor() {
        this.vy         = 11;
        this.vx         = 0;
        this.isMovingLeft  = false;
        this.isMovingRight = false;
        this.isDead     = false;
        this.width      = 55;
        this.height     = 40;
        this.cx         = 0;
        this.cy         = 0;
        this.cwidth     = 110;
        this.cheight    = 80;
        this.dir        = "left";
        this.x          = width / 2 - this.width / 2;
        this.y          = height;
      }
      draw() {
        try {
          if (this.dir == "right")      this.cy = 121;
          else if (this.dir == "left")  this.cy = 201;
          else if (this.dir == "right_land") this.cy = 289;
          else if (this.dir == "left_land")  this.cy = 371;

          ctx.drawImage(
            image,
            this.cx, this.cy, this.cwidth, this.cheight,
            this.x,  this.y,  this.width,  this.height
          );
        } catch (e) { /* пока не загружен спрайт */ }
      }
      jump() {
        this.vy = -8;
      }
      jumpHigh() {
        this.vy = -16;
      }
    }
    player = new Player();

    class Platform {
      constructor() {
        this.width  = 70;
        this.height = 17;
        this.x      = Math.random() * (width - this.width);
        this.y      = position;
        position   += (height / platformCount);
        this.flag   = 0;
        this.state  = 0;
        this.cx     = 0;
        this.cy     = 0;
        this.cwidth = 105;
        this.cheight= 31;

        // Выбираем тип платформы согласно текущему счёту
        if (score >= 5000) this.types = [2,3,3,3,4,4,4,4];
        else if (score >= 2000 && score < 5000) this.types = [2,2,2,3,3,3,3,4,4,4,4];
        else if (score >= 1000 && score < 2000) this.types = [2,2,2,3,3,3,3,3];
        else if (score >= 500  && score < 1000) this.types = [1,1,1,1,1,2,2,2,2,3,3,3,3];
        else if (score >= 100  && score < 500) this.types = [1,1,1,1,2,2];
        else this.types = [1];

        this.type = this.types[Math.floor(Math.random() * this.types.length)];

        // Исключаем подряд два «разрушающихся» (type=3)
        if (this.type == 3 && broken < 1) {
          broken++;
        } else if (this.type == 3 && broken >= 1) {
          this.type = 1;
          broken = 0;
        }

        this.moved = 0;
        this.vx    = 1;
      }
      draw() {
        try {
          if (this.type == 1) this.cy = 0;
          else if (this.type == 2) this.cy = 61;
          else if (this.type == 3 && this.flag === 0) this.cy = 31;
          else if (this.type == 3 && this.flag == 1) this.cy = 1000; // скрываем
          else if (this.type == 4 && this.state === 0) this.cy = 90;
          else if (this.type == 4 && this.state == 1) this.cy = 1000;// скрываем

          ctx.drawImage(
            image,
            this.cx, this.cy, this.cwidth, this.cheight,
            this.x,  this.y,  this.width,  this.height
          );
        } catch (e) { /* может не загрузиться спрайт */ }
      }
    }

    class PlatformBrokenSub {
      constructor() {
        this.height = 30;
        this.width  = 70;
        this.x      = 0;
        this.y      = 0;
        this.cx     = 0;
        this.cy     = 554;
        this.cwidth = 105;
        this.cheight= 60;
        this.appearance = false;
      }
      draw() {
        try {
          if (this.appearance === true) {
            ctx.drawImage(
              image,
              this.cx, this.cy, this.cwidth, this.cheight,
              this.x, this.y, this.width, this.height
            );
          }
        } catch (e) {}
      }
    }
    let platform_broken_substitute = new PlatformBrokenSub();

    class SpringClass {
      constructor() {
        this.x      = 0;
        this.y      = 0;
        this.width  = 26;
        this.height = 30;
        this.cx     = 0;
        this.cy     = 0;
        this.cwidth = 45;
        this.cheight= 53;
        this.state  = 0;
      }
      draw() {
        try {
          if (this.state === 0) this.cy = 445;
          else if (this.state == 1) this.cy = 501;
          ctx.drawImage(
            image,
            this.cx, this.cy, this.cwidth, this.cheight,
            this.x,  this.y,  this.width,  this.height
          );
        } catch (e) {}
      }
    }
    let Spring = new SpringClass();

    // Заполняем массив платформ стартово
    for (let i = 0; i < platformCount; i++) {
      platforms.push(new Platform());
    }


    /* =================== Функции игрового цикла =================== */

    // Очищает canvas
    function paintCanvas() {
      ctx.clearRect(0, 0, width, height);
    }

    // Обновление состояния игрока (позиция, гравитация, столкновения)
    function playerCalc() {
      // Устанавливаем спрайт в зависимости от направления/высоты
      if (dir == "left") {
        player.dir = "left";
        if (player.vy < -7 && player.vy > -15) player.dir = "left_land";
      } 
      else if (dir == "right") {
        player.dir = "right";
        if (player.vy < -7 && player.vy > -15) player.dir = "right_land";
      }

      // Обработка нажатия клавиш
      document.onkeydown = function(e) {
        let key = e.keyCode;
        if (key == 37) { // ←
          dir = "left";
          player.isMovingLeft = true;
        } else if (key == 39) { // →
          dir = "right";
          player.isMovingRight = true;
        }
        if (key == 32) { // пробел
          if (firstRun === true) init();
          else reset();
        }
      };
      document.onkeyup = function(e) {
        let key = e.keyCode;
        if (key == 37) {
          dir = "left";
          player.isMovingLeft = false;
        } else if (key == 39) {
          dir = "right";
          player.isMovingRight = false;
        }
      };

      // Горизонтальная скорость игрока
      if (player.isMovingLeft === true) {
        player.x += player.vx;
        player.vx -= 0.15;
      } else {
        player.x += player.vx;
        if (player.vx < 0) player.vx += 0.1;
      }
      if (player.isMovingRight === true) {
        player.x += player.vx;
        player.vx += 0.15;
      } else {
        player.x += player.vx;
        if (player.vx > 0) player.vx -= 0.1;
      }
      // Ограничиваем скорость
      if (player.vx > 8)  player.vx = 8;
      if (player.vx < -8) player.vx = -8;

      // Если игрок «приземлился» на базу (основу) — прыгаем
      if ((player.y + player.height) > base.y && base.y < height) {
        player.jump();
      }

      // Если база ушла вниз, и игрок упал ниже экрана — game over
      if (base.y > height && (player.y + player.height) > height && player.isDead != "lol") {
        player.isDead = true;
      }

      // Проходим через стены
      if (player.x > width) player.x = 0 - player.width;
      else if (player.x < 0 - player.width) player.x = width;

      // Вертикальное движение игрока: гравитация и «скроллинг» платформ
      if (player.y >= (height / 2) - (player.height / 2)) {
        player.y += player.vy;
        player.vy += gravity;
      } else {
        // Когда игрок достигает середины по вертикали, мы движем все платформы вниз
        platforms.forEach(function(p, i) {
          if (player.vy < 0) {
            p.y -= player.vy;
          }
          // Когда платформа вынесена за экран снизу, создаём новую сверху
          if (p.y > height) {
            platforms[i] = new Platform();
            platforms[i].y = p.y - height;
          }
        });
        base.y   -= player.vy;
        player.vy += gravity;
        if (player.vy >= 0) {
          player.y  += player.vy;
          player.vy += gravity;
        }
        score++;
      }

      // Проверяем коллизии «игрок — платформа» и «игрок — пружинка»
      collides();

      // Если игрок умер, запускаем gameOver
      if (player.isDead === true) gameOver();
    }

    // Отрисовываем пружинку (Spring) над первой платформой типа 1/2
    function springCalc() {
      let s = Spring;
      let p = platforms[0];
      if (p.type == 1 || p.type == 2) {
        s.x = p.x + p.width / 2 - s.width / 2;
        s.y = p.y - p.height - 10;
        if (s.y > height / 1.1) s.state = 0;
        s.draw();
      } else {
        s.x = 0 - s.width;
        s.y = 0 - s.height;
      }
    }

    // Отрисовываем все платформы, включая ломающиеся и шатающиеся, и «сломанные» отдельно
    function platformCalc() {
      let subs = platform_broken_substitute;
      platforms.forEach(function(p, i) {
        // Двигающиеся платформы (type=2)
        if (p.type == 2) {
          if (p.x < 0 || p.x + p.width > width) p.vx *= -1;
          p.x += p.vx;
        }
        // Если платформа ломающаяся (type=3) и «сломалась» (flag=1), создаём «ломающийся фрагмент»
        if (p.flag == 1 && subs.appearance === false && jumpCount === 0) {
          subs.x           = p.x;
          subs.y           = p.y;
          subs.appearance  = true;
          jumpCount++;
        }
        p.draw();
      });
      // Если «сломавшийся фрагмент» появился, отрисовываем и снижаем его вниз
      if (subs.appearance === true) {
        subs.draw();
        subs.y += 8;
      }
      if (subs.y > height) subs.appearance = false;
    }

    // Коллизии: платформа и пружинка
    function collides() {
      // Платформы
      platforms.forEach(function(p, i) {
        if (
          player.vy > 0 &&
          p.state === 0 &&
          (player.x + 15 < p.x + p.width) &&
          (player.x + player.width - 15 > p.x) &&
          (player.y + player.height > p.y) &&
          (player.y + player.height < p.y + p.height)
        ) {
          // Если платформа ломается (type=3) и ещё не сломана:
          if (p.type == 3 && p.flag === 0) {
            p.flag   = 1;
            jumpCount= 0;
            return;
          }
          // Если платформа исчезающая (type=4) и ещё не исчезла:
          else if (p.type == 4 && p.state === 0) {
            player.jump();
            p.state = 1;
          }
          // Если она уже сломана (или исчезла) — пропускаем коллизию
          else if (p.flag == 1) {
            return;
          }
          else {
            player.jump();
          }
        }
      });

      // Пружинка
      let s = Spring;
      if (
        player.vy > 0 &&
        (s.state === 0) &&
        (player.x + 15 < s.x + s.width) &&
        (player.x + player.width - 15 > s.x) &&
        (player.y + player.height > s.y) &&
        (player.y + player.height < s.y + s.height)
      ) {
        s.state = 1;
        player.jumpHigh();
      }
    }

    // Обновляем табло со счетом
    function updateScore() {
      let scoreText = document.getElementById("score");
      scoreText.innerText = score;
    }

    // Game Over: анимируем уход платформ, затем показываем экран «Game Over»
    function gameOver() {
      platforms.forEach(function(p, i) {
        p.y -= 12; // «подтянем» все платформы вверх
      });
      if (player.y > height / 2 && flag === 0) {
        player.y -= 8;
        player.vy = 0;
      } 
      else if (player.y < height / 2) {
        flag = 1;
      } 
      else if (player.y + player.height > height) {
        // Показываем «Game Over» и прячем ScoreBoard
        showGameOverMenu();
        hideScore();
        player.isDead = "lol";
      }
    }

    // Основная функция обновления (отрисовка кадра)
    function update() {
      paintCanvas();
      platformCalc();
      springCalc();
      playerCalc();
      player.draw();
      base.draw();
      updateScore();
    }

    // =========== Функция init(): запускаем игру при нажатии «Play» ===========
    function init() {
      console.log(">> init() вызвана"); // смотрим в консоли DevTools

      // Сбросим счётчики и параметры
      jumpCount = 0;
      firstRun  = false;

      // Сразу очистим холст
      paintCanvas();

      // Запускаем бесконечный цикл через requestAnimationFrame
      animloop = function() {
        update();
        requestAnimationFrame(animloop);
      };
      animloop();

      // Скрываем главное меню и показываем ScoreBoard
      hideMainMenu();
      showScore();
    }

    // =========== Функция reset(): перезапуск игры при «Restart» ===========
    function reset() {
      console.log(">> reset() вызвана");

      hideGameOverMenu();
      showScore();
      player.isDead = false;
      flag           = 0;
      position       = 0;
      score          = 0;
      jumpCount      = 0;

      // Пересоздаём все объекты
      base                      = new Base();
      player                    = new Player();
      Spring                    = new SpringClass();
      platform_broken_substitute= new PlatformBrokenSub();
      platforms                 = [];
      for (let i = 0; i < platformCount; i++) {
        platforms.push(new Platform());
      }
    }

    // ======== Показываем/скрываем меню ========
    function hideMainMenu() {
      document.getElementById("mainMenu").style.display = 'none';
    }
    function showMainMenu() {
      document.getElementById("mainMenu").style.display = 'flex';
    }
    function showGameOverMenu() {
      document.getElementById("gameOverMenu").style.display = 'flex';
    }
    function hideGameOverMenu() {
      document.getElementById("gameOverMenu").style.display = 'none';
    }

    function showScore() {
      document.getElementById("scoreBoard").style.display = 'flex';
    }
    function hideScore() {
      document.getElementById("scoreBoard").style.display = 'none';
    }

    // ======= «Меню-цикл» (например, чтобы фоновая анимация шла, пока видны меню) =======
    function menuLoop() {
      update();
      requestAnimationFrame(menuLoop);
    }
    // Запускаем сразу, чтобы отображалось хотя бы несколько кадров меню перед «Play»
    menuLoop();

    // ======= On-screen-кнопки «←» и «→» =======
    const leftBtn  = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');
    if (leftBtn && rightBtn) {
      // Нажатие/удержание «←»
      leftBtn.addEventListener('mousedown', () => {
        dir = 'left';
        player.isMovingLeft = true;
      });
      leftBtn.addEventListener('mouseup', () => {
        player.isMovingLeft = false;
      });
      leftBtn.addEventListener('mouseleave', () => {
        player.isMovingLeft = false;
      });
      leftBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        dir = 'left';
        player.isMovingLeft = true;
      });
      leftBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        player.isMovingLeft = false;
      });

      // Нажатие/удержание «→»
      rightBtn.addEventListener('mousedown', () => {
        dir = 'right';
        player.isMovingRight = true;
      });
      rightBtn.addEventListener('mouseup', () => {
        player.isMovingRight = false;
      });
      rightBtn.addEventListener('mouseleave', () => {
        player.isMovingRight = false;
      });
      rightBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        dir = 'right';
        player.isMovingRight = true;
      });
      rightBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        player.isMovingRight = false;
      });
    }
  </script>
</body>
</html>
